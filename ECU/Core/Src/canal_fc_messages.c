/*
 * canal_fc_messages.c
 *
 *  WARNING: DO NOT EDIT. THIS WAS AN AUTOGENERATED FILE.
 *
 *  Created on: 2023/5/23 
 *     Authors: Samuel Parent, Dharak Verma
 *
 *                    ..::^~~~!!~~~^^:..
 *                .:^!7??JJJJJJJJJJJJ??7!~:.
 *              :~7?JJJ???????????????JJJJ??!^.
 *           .^7?JJJ???JJJJJJ??????????????JJJ?~:
 *          ^7JJ???????777777???JJJJJJJ???????JJ?~.
 *        .!JJ???????????7!~^::::^~!!7??JJ???????J7:
 *       :7JJJ??????????JJJJ??7~:    ..:~7?J??????J?^
 *      .7J???????????????????JJ?!.       :7J??????J?^
 *     .~J??????????????????JJJJ?!.       .7J???????J7.
 *     :?J?????????????JJJJ??7!^.      .:~???????????J~
 *     ^???????????JJJ??7~^:..      .:~7?JJ??????????J!.
 *     ^????????JJ?7~^:.        .:~!?JJJ?????????????J!.
 *     ^????????!^.          .:~7?JJJ????????????????J!.
 *     .7J????!.            :7?JJ?????????????????????^
 *      ~JJ?J7.             ~JJJJ???????????????????J!.
 *      .!J???^.            .^!7?JJJJJJ????????????J7:
 *       .!?J??7^.              .:^~!7???JJJJJ????J7:
 *        .^?JJJJ?7~.                 ..:^~~!7????!.
 *          .!?JJJJ?:                         ..::
 *            :~??!:
 *              ..
 */
 

 /*********************************************************
 *                      INCLUDES
 *********************************************************/
#include <stdint.h>
#include "canal_fc_messages.h"

/*********************************************************
 *                       MACROS
 *********************************************************/
#define CANAL_DATA_BITS (64U)

// CANAL_BIT_MASK will output a mask with (__length__) number of 1's
// e.g.: CANAL_BIT_MASK(5) = 0b0001'1111
#define CANAL_BIT_MASK(__length__) 	(UINT64_MAX >> (CANAL_DATA_BITS - __length__))
    
// CANAL_BIT_INDEX_BE will take a bit index and convert it to work with big endian data
#define CANAL_BIT_INDEX_BE(__idx__) 	((7 - ((__idx__) % 8)) + (((__idx__) / 8) * 8))

// CANAL_CLEAR_BITS will output the contents of (__data__) with bits from (__start__)
// to (__start__+__length__) set to 0
#define CANAL_CLEAR_BITS(__data__, __start__, __length__) 	(~((CANAL_BIT_MASK(__length__) << __start__)) & (__data__))

// CANAL_GET_BITS will output the bits from (__data__) at bit positions (__start__)
// to (__start__+__length__)
#define CANAL_GET_BITS(__data__, __start__, __length__) 	((__data__ >>  __start__) & CANAL_BIT_MASK(__length__))

// CANAL_SET_BITS will take the first (__length__) bits from (__input__) and set them
// to (__output__) from bit position (__start__) to (__start__ + __length__)
#define CANAL_SET_BITS(__input__, __output__, __start__, __length__) 	(CANAL_CLEAR_BITS(__output__, __start__, __length__) | ((uint64_t)(__input__) & CANAL_BIT_MASK(__length__)) << __start__)

// CANAL_TWOS_COMPLEMENT will take the twos complement of (__data__)
#define CANAL_TWOS_COMPLEMENT(__data__, __length__) (((~(__data__))+1) & CANAL_BIT_MASK(__length__))

// CANAL_IS_NEGATIVE checks the msb to see if (__data__) is negative
#define CANAL_IS_NEGATIVE(__data__, __length__) (((__data__) & ((uint64_t)1 << (__length__-1))) != 0)

// CANAL_TO_SIGNED converts (__data__) to a signed value
#define CANAL_TO_SIGNED(__data__, __length__)   ((signed)(CANAL_IS_NEGATIVE(__data__, __length__) ? -(CANAL_TWOS_COMPLEMENT(__data__, __length__)) : __data__))

    
/*********************************************************
*                 GLOBAL STRUCT DEFINITIONS
*********************************************************/

volatile TsAMK1_SetPoints1              AMK1_SetPoints1;
volatile TsAMK1_ActualValues2           AMK1_ActualValues2;
volatile TsAMK1_ActualValues1           AMK1_ActualValues1;
volatile TsAMK0_ActualValues1           AMK0_ActualValues1;
volatile TsAMK0_ActualValues2           AMK0_ActualValues2;
volatile TsAMK0_SetPoints1              AMK0_SetPoints1;
volatile TsAccelerometerData            AccelerometerData;
volatile TsLvBatteryData                LvBatteryData;
volatile TsVehicleInfo                  VehicleInfo;
volatile TsCoolingControllerAnswer      CoolingControllerAnswer;
volatile TsDashboardAnswer              DashboardAnswer;
volatile TsPiuControllerAnswer          PiuControllerAnswer;
volatile TsPiuControllerQuestion        PiuControllerQuestion;
volatile TsDashboardQuestion            DashboardQuestion;
volatile TsCoolingControllerQuestion    CoolingControllerQuestion;
volatile TsDashboardData                DashboardData;
volatile TsTemperatureInfo              TemperatureInfo;
volatile TsCoolingLoopsData             CoolingLoopsData;
volatile TsCoolingLoopModes             CoolingLoopModes;
volatile TsPedalPositions               PedalPositions;

/*********************************************************
 *                    HELPER FUNCTIONS
 *********************************************************/

static uint64_t getDataWordFromByteArray(uint8_t* rawData) {
	uint64_t ret = 0;

	for (int8_t i = 7; i >= 0; i--) {
		ret <<= 8;
		ret += rawData[i];
	}

	return ret;
}

static void setDataWordIntoByteArray(uint64_t dataWord, uint8_t *dataOutput) {
	for (int8_t i = 0; i < 8; i++) {
		dataOutput[i] = (uint8_t) (dataWord & CANAL_BIT_MASK(8));
		dataWord >>= 8;
	}
}

static uint64_t shift_endianness(uint64_t val, uint8_t num_bits) {
	unsigned long long result = 0;
	unsigned long long temp_value = val;
	unsigned int num_bytes = (num_bits + 7) / 8;
	unsigned int num_shifts = (num_bytes - 1) * 8;
	
	for (unsigned int i = 0; i < num_bytes; ++i) {
		result |= ((temp_value >> (num_shifts - (i * 8))) & 0xFFULL) << (i * 8);
	}

	return result;
}

/*********************************************************
 *                    CAN FUNCTIONS
 *********************************************************/
 
TeCanALRet Unmarshal_AMK1_ActualValues2(uint8_t *RxData) {
	uint64_t data;
	TsAMK1_ActualValues2 temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.AMK_TempMotor = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES2_AMK_TEMPMOTOR_START,
            AMK1_ACTUALVALUES2_AMK_TEMPMOTOR_LENGTH),
            AMK1_ACTUALVALUES2_AMK_TEMPMOTOR_LENGTH);
            
        temp.AMK_TempInverter = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES2_AMK_TEMPINVERTER_START,
            AMK1_ACTUALVALUES2_AMK_TEMPINVERTER_LENGTH),
            AMK1_ACTUALVALUES2_AMK_TEMPINVERTER_LENGTH);
            
        temp.AMK_ErrorInfo = CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES2_AMK_ERRORINFO_START,
            AMK1_ACTUALVALUES2_AMK_ERRORINFO_LENGTH);
            
        temp.AMK_TempIGBT = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES2_AMK_TEMPIGBT_START,
            AMK1_ACTUALVALUES2_AMK_TEMPIGBT_LENGTH),
            AMK1_ACTUALVALUES2_AMK_TEMPIGBT_LENGTH);
            
	//  Apply linear conversion
	temp.AMK_TempMotor = (temp.AMK_TempMotor
			* AMK1_ACTUALVALUES2_AMK_TEMPMOTOR_FACTOR)
			+ AMK1_ACTUALVALUES2_AMK_TEMPMOTOR_OFFSET; 
            
	temp.AMK_TempInverter = (temp.AMK_TempInverter
			* AMK1_ACTUALVALUES2_AMK_TEMPINVERTER_FACTOR)
			+ AMK1_ACTUALVALUES2_AMK_TEMPINVERTER_OFFSET; 
            
	temp.AMK_ErrorInfo = (temp.AMK_ErrorInfo
			* AMK1_ACTUALVALUES2_AMK_ERRORINFO_FACTOR)
			+ AMK1_ACTUALVALUES2_AMK_ERRORINFO_OFFSET; 
            
	temp.AMK_TempIGBT = (temp.AMK_TempIGBT
			* AMK1_ACTUALVALUES2_AMK_TEMPIGBT_FACTOR)
			+ AMK1_ACTUALVALUES2_AMK_TEMPIGBT_OFFSET; 
            
	//  Writing to global struct instance
	AMK1_ActualValues2 = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_AMK1_ActualValues1(uint8_t *RxData) {
	uint64_t data;
	TsAMK1_ActualValues1 temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.AMK_bSystemReady = CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_BSYSTEMREADY_START,
            AMK1_ACTUALVALUES1_AMK_BSYSTEMREADY_LENGTH);
            
        temp.AMK_bError = CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_BERROR_START,
            AMK1_ACTUALVALUES1_AMK_BERROR_LENGTH);
            
        temp.AMK_bWarn = CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_BWARN_START,
            AMK1_ACTUALVALUES1_AMK_BWARN_LENGTH);
            
        temp.AMK_bQuitDcOn = CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_BQUITDCON_START,
            AMK1_ACTUALVALUES1_AMK_BQUITDCON_LENGTH);
            
        temp.AMK_bDcOn = CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_BDCON_START,
            AMK1_ACTUALVALUES1_AMK_BDCON_LENGTH);
            
        temp.AMK_bQuitInverterOn = CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_BQUITINVERTERON_START,
            AMK1_ACTUALVALUES1_AMK_BQUITINVERTERON_LENGTH);
            
        temp.AMK_bInverterOn = CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_BINVERTERON_START,
            AMK1_ACTUALVALUES1_AMK_BINVERTERON_LENGTH);
            
        temp.AMK_bDerating = CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_BDERATING_START,
            AMK1_ACTUALVALUES1_AMK_BDERATING_LENGTH);
            
        temp.AMK_ActualVelocity = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_ACTUALVELOCITY_START,
            AMK1_ACTUALVALUES1_AMK_ACTUALVELOCITY_LENGTH),
            AMK1_ACTUALVALUES1_AMK_ACTUALVELOCITY_LENGTH);
            
        temp.AMK_TorqueCurrent = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_TORQUECURRENT_START,
            AMK1_ACTUALVALUES1_AMK_TORQUECURRENT_LENGTH),
            AMK1_ACTUALVALUES1_AMK_TORQUECURRENT_LENGTH);
            
        temp.AMK_MagnetizingCurrent = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK1_ACTUALVALUES1_AMK_MAGNETIZINGCURRENT_START,
            AMK1_ACTUALVALUES1_AMK_MAGNETIZINGCURRENT_LENGTH),
            AMK1_ACTUALVALUES1_AMK_MAGNETIZINGCURRENT_LENGTH);
            
	//  Apply linear conversion
	temp.AMK_bSystemReady = (temp.AMK_bSystemReady
			* AMK1_ACTUALVALUES1_AMK_BSYSTEMREADY_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_BSYSTEMREADY_OFFSET; 
            
	temp.AMK_bError = (temp.AMK_bError
			* AMK1_ACTUALVALUES1_AMK_BERROR_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_BERROR_OFFSET; 
            
	temp.AMK_bWarn = (temp.AMK_bWarn
			* AMK1_ACTUALVALUES1_AMK_BWARN_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_BWARN_OFFSET; 
            
	temp.AMK_bQuitDcOn = (temp.AMK_bQuitDcOn
			* AMK1_ACTUALVALUES1_AMK_BQUITDCON_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_BQUITDCON_OFFSET; 
            
	temp.AMK_bDcOn = (temp.AMK_bDcOn
			* AMK1_ACTUALVALUES1_AMK_BDCON_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_BDCON_OFFSET; 
            
	temp.AMK_bQuitInverterOn = (temp.AMK_bQuitInverterOn
			* AMK1_ACTUALVALUES1_AMK_BQUITINVERTERON_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_BQUITINVERTERON_OFFSET; 
            
	temp.AMK_bInverterOn = (temp.AMK_bInverterOn
			* AMK1_ACTUALVALUES1_AMK_BINVERTERON_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_BINVERTERON_OFFSET; 
            
	temp.AMK_bDerating = (temp.AMK_bDerating
			* AMK1_ACTUALVALUES1_AMK_BDERATING_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_BDERATING_OFFSET; 
            
	temp.AMK_ActualVelocity = (temp.AMK_ActualVelocity
			* AMK1_ACTUALVALUES1_AMK_ACTUALVELOCITY_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_ACTUALVELOCITY_OFFSET; 
            
	temp.AMK_TorqueCurrent = (temp.AMK_TorqueCurrent
			* AMK1_ACTUALVALUES1_AMK_TORQUECURRENT_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_TORQUECURRENT_OFFSET; 
            
	temp.AMK_MagnetizingCurrent = (temp.AMK_MagnetizingCurrent
			* AMK1_ACTUALVALUES1_AMK_MAGNETIZINGCURRENT_FACTOR)
			+ AMK1_ACTUALVALUES1_AMK_MAGNETIZINGCURRENT_OFFSET; 
            
	//  Writing to global struct instance
	AMK1_ActualValues1 = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_AMK0_ActualValues1(uint8_t *RxData) {
	uint64_t data;
	TsAMK0_ActualValues1 temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.AMK_bSystemReady = CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_BSYSTEMREADY_START,
            AMK0_ACTUALVALUES1_AMK_BSYSTEMREADY_LENGTH);
            
        temp.AMK_bError = CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_BERROR_START,
            AMK0_ACTUALVALUES1_AMK_BERROR_LENGTH);
            
        temp.AMK_bWarn = CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_BWARN_START,
            AMK0_ACTUALVALUES1_AMK_BWARN_LENGTH);
            
        temp.AMK_bQuitDcOn = CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_BQUITDCON_START,
            AMK0_ACTUALVALUES1_AMK_BQUITDCON_LENGTH);
            
        temp.AMK_bDcOn = CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_BDCON_START,
            AMK0_ACTUALVALUES1_AMK_BDCON_LENGTH);
            
        temp.AMK_bQuitInverterOn = CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_BQUITINVERTERON_START,
            AMK0_ACTUALVALUES1_AMK_BQUITINVERTERON_LENGTH);
            
        temp.AMK_bInverterOn = CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_BINVERTERON_START,
            AMK0_ACTUALVALUES1_AMK_BINVERTERON_LENGTH);
            
        temp.AMK_bDerating = CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_BDERATING_START,
            AMK0_ACTUALVALUES1_AMK_BDERATING_LENGTH);
            
        temp.AMK_ActualVelocity = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_ACTUALVELOCITY_START,
            AMK0_ACTUALVALUES1_AMK_ACTUALVELOCITY_LENGTH),
            AMK0_ACTUALVALUES1_AMK_ACTUALVELOCITY_LENGTH);
            
        temp.AMK_TorqueCurrent = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_TORQUECURRENT_START,
            AMK0_ACTUALVALUES1_AMK_TORQUECURRENT_LENGTH),
            AMK0_ACTUALVALUES1_AMK_TORQUECURRENT_LENGTH);
            
        temp.AMK_MagnetizingCurrent = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES1_AMK_MAGNETIZINGCURRENT_START,
            AMK0_ACTUALVALUES1_AMK_MAGNETIZINGCURRENT_LENGTH),
            AMK0_ACTUALVALUES1_AMK_MAGNETIZINGCURRENT_LENGTH);
            
	//  Apply linear conversion
	temp.AMK_bSystemReady = (temp.AMK_bSystemReady
			* AMK0_ACTUALVALUES1_AMK_BSYSTEMREADY_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_BSYSTEMREADY_OFFSET; 
            
	temp.AMK_bError = (temp.AMK_bError
			* AMK0_ACTUALVALUES1_AMK_BERROR_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_BERROR_OFFSET; 
            
	temp.AMK_bWarn = (temp.AMK_bWarn
			* AMK0_ACTUALVALUES1_AMK_BWARN_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_BWARN_OFFSET; 
            
	temp.AMK_bQuitDcOn = (temp.AMK_bQuitDcOn
			* AMK0_ACTUALVALUES1_AMK_BQUITDCON_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_BQUITDCON_OFFSET; 
            
	temp.AMK_bDcOn = (temp.AMK_bDcOn
			* AMK0_ACTUALVALUES1_AMK_BDCON_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_BDCON_OFFSET; 
            
	temp.AMK_bQuitInverterOn = (temp.AMK_bQuitInverterOn
			* AMK0_ACTUALVALUES1_AMK_BQUITINVERTERON_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_BQUITINVERTERON_OFFSET; 
            
	temp.AMK_bInverterOn = (temp.AMK_bInverterOn
			* AMK0_ACTUALVALUES1_AMK_BINVERTERON_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_BINVERTERON_OFFSET; 
            
	temp.AMK_bDerating = (temp.AMK_bDerating
			* AMK0_ACTUALVALUES1_AMK_BDERATING_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_BDERATING_OFFSET; 
            
	temp.AMK_ActualVelocity = (temp.AMK_ActualVelocity
			* AMK0_ACTUALVALUES1_AMK_ACTUALVELOCITY_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_ACTUALVELOCITY_OFFSET; 
            
	temp.AMK_TorqueCurrent = (temp.AMK_TorqueCurrent
			* AMK0_ACTUALVALUES1_AMK_TORQUECURRENT_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_TORQUECURRENT_OFFSET; 
            
	temp.AMK_MagnetizingCurrent = (temp.AMK_MagnetizingCurrent
			* AMK0_ACTUALVALUES1_AMK_MAGNETIZINGCURRENT_FACTOR)
			+ AMK0_ACTUALVALUES1_AMK_MAGNETIZINGCURRENT_OFFSET; 
            
	//  Writing to global struct instance
	AMK0_ActualValues1 = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_AMK0_ActualValues2(uint8_t *RxData) {
	uint64_t data;
	TsAMK0_ActualValues2 temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.AMK_TempMotor = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES2_AMK_TEMPMOTOR_START,
            AMK0_ACTUALVALUES2_AMK_TEMPMOTOR_LENGTH),
            AMK0_ACTUALVALUES2_AMK_TEMPMOTOR_LENGTH);
            
        temp.AMK_TempInverter = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES2_AMK_TEMPINVERTER_START,
            AMK0_ACTUALVALUES2_AMK_TEMPINVERTER_LENGTH),
            AMK0_ACTUALVALUES2_AMK_TEMPINVERTER_LENGTH);
            
        temp.AMK_ErrorInfo = CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES2_AMK_ERRORINFO_START,
            AMK0_ACTUALVALUES2_AMK_ERRORINFO_LENGTH);
            
        temp.AMK_TempIGBT = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            AMK0_ACTUALVALUES2_AMK_TEMPIGBT_START,
            AMK0_ACTUALVALUES2_AMK_TEMPIGBT_LENGTH),
            AMK0_ACTUALVALUES2_AMK_TEMPIGBT_LENGTH);
            
	//  Apply linear conversion
	temp.AMK_TempMotor = (temp.AMK_TempMotor
			* AMK0_ACTUALVALUES2_AMK_TEMPMOTOR_FACTOR)
			+ AMK0_ACTUALVALUES2_AMK_TEMPMOTOR_OFFSET; 
            
	temp.AMK_TempInverter = (temp.AMK_TempInverter
			* AMK0_ACTUALVALUES2_AMK_TEMPINVERTER_FACTOR)
			+ AMK0_ACTUALVALUES2_AMK_TEMPINVERTER_OFFSET; 
            
	temp.AMK_ErrorInfo = (temp.AMK_ErrorInfo
			* AMK0_ACTUALVALUES2_AMK_ERRORINFO_FACTOR)
			+ AMK0_ACTUALVALUES2_AMK_ERRORINFO_OFFSET; 
            
	temp.AMK_TempIGBT = (temp.AMK_TempIGBT
			* AMK0_ACTUALVALUES2_AMK_TEMPIGBT_FACTOR)
			+ AMK0_ACTUALVALUES2_AMK_TEMPIGBT_OFFSET; 
            
	//  Writing to global struct instance
	AMK0_ActualValues2 = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_AccelerometerData(uint8_t *RxData) {
	uint64_t data;
	TsAccelerometerData temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.AccelLateral = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            ACCELEROMETERDATA_ACCELLATERAL_START,
            ACCELEROMETERDATA_ACCELLATERAL_LENGTH),
            ACCELEROMETERDATA_ACCELLATERAL_LENGTH);
            
        temp.AccelLongitudinal = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            ACCELEROMETERDATA_ACCELLONGITUDINAL_START,
            ACCELEROMETERDATA_ACCELLONGITUDINAL_LENGTH),
            ACCELEROMETERDATA_ACCELLONGITUDINAL_LENGTH);
            
        temp.YawRate = CANAL_TO_SIGNED(CANAL_GET_BITS(data,
            ACCELEROMETERDATA_YAWRATE_START,
            ACCELEROMETERDATA_YAWRATE_LENGTH),
            ACCELEROMETERDATA_YAWRATE_LENGTH);
            
	//  Apply linear conversion
	temp.AccelLateral = (temp.AccelLateral
			* ACCELEROMETERDATA_ACCELLATERAL_FACTOR)
			+ ACCELEROMETERDATA_ACCELLATERAL_OFFSET; 
            
	temp.AccelLongitudinal = (temp.AccelLongitudinal
			* ACCELEROMETERDATA_ACCELLONGITUDINAL_FACTOR)
			+ ACCELEROMETERDATA_ACCELLONGITUDINAL_OFFSET; 
            
	temp.YawRate = (temp.YawRate
			* ACCELEROMETERDATA_YAWRATE_FACTOR)
			+ ACCELEROMETERDATA_YAWRATE_OFFSET; 
            
	//  Writing to global struct instance
	AccelerometerData = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_LvBatteryData(uint8_t *RxData) {
	uint64_t data;
	TsLvBatteryData temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.GlvCurrent = CANAL_GET_BITS(data,
            LVBATTERYDATA_GLVCURRENT_START,
            LVBATTERYDATA_GLVCURRENT_LENGTH);
            
        temp.GlvVoltage = CANAL_GET_BITS(data,
            LVBATTERYDATA_GLVVOLTAGE_START,
            LVBATTERYDATA_GLVVOLTAGE_LENGTH);
            
	//  Apply linear conversion
	temp.GlvCurrent = (temp.GlvCurrent
			* LVBATTERYDATA_GLVCURRENT_FACTOR)
			+ LVBATTERYDATA_GLVCURRENT_OFFSET; 
            
	temp.GlvVoltage = (temp.GlvVoltage
			* LVBATTERYDATA_GLVVOLTAGE_FACTOR)
			+ LVBATTERYDATA_GLVVOLTAGE_OFFSET; 
            
	//  Writing to global struct instance
	LvBatteryData = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_CoolingControllerAnswer(uint8_t *RxData) {
	uint64_t data;
	TsCoolingControllerAnswer temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.CcuAnswer = CANAL_GET_BITS(data,
            COOLINGCONTROLLERANSWER_CCUANSWER_START,
            COOLINGCONTROLLERANSWER_CCUANSWER_LENGTH);
            
	//  Apply linear conversion
	temp.CcuAnswer = (temp.CcuAnswer
			* COOLINGCONTROLLERANSWER_CCUANSWER_FACTOR)
			+ COOLINGCONTROLLERANSWER_CCUANSWER_OFFSET; 
            
	//  Writing to global struct instance
	CoolingControllerAnswer = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_DashboardAnswer(uint8_t *RxData) {
	uint64_t data;
	TsDashboardAnswer temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.DcuAnswer = CANAL_GET_BITS(data,
            DASHBOARDANSWER_DCUANSWER_START,
            DASHBOARDANSWER_DCUANSWER_LENGTH);
            
	//  Apply linear conversion
	temp.DcuAnswer = (temp.DcuAnswer
			* DASHBOARDANSWER_DCUANSWER_FACTOR)
			+ DASHBOARDANSWER_DCUANSWER_OFFSET; 
            
	//  Writing to global struct instance
	DashboardAnswer = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_PiuControllerAnswer(uint8_t *RxData) {
	uint64_t data;
	TsPiuControllerAnswer temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.PiuAnswer = CANAL_GET_BITS(data,
            PIUCONTROLLERANSWER_PIUANSWER_START,
            PIUCONTROLLERANSWER_PIUANSWER_LENGTH);
            
	//  Apply linear conversion
	temp.PiuAnswer = (temp.PiuAnswer
			* PIUCONTROLLERANSWER_PIUANSWER_FACTOR)
			+ PIUCONTROLLERANSWER_PIUANSWER_OFFSET; 
            
	//  Writing to global struct instance
	PiuControllerAnswer = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_DashboardData(uint8_t *RxData) {
	uint64_t data;
	TsDashboardData temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.GpsVehicleSpeed = CANAL_GET_BITS(data,
            DASHBOARDDATA_GPSVEHICLESPEED_START,
            DASHBOARDDATA_GPSVEHICLESPEED_LENGTH);
            
	//  Apply linear conversion
	temp.GpsVehicleSpeed = (temp.GpsVehicleSpeed
			* DASHBOARDDATA_GPSVEHICLESPEED_FACTOR)
			+ DASHBOARDDATA_GPSVEHICLESPEED_OFFSET; 
            
	//  Writing to global struct instance
	DashboardData = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_CoolingLoopsData(uint8_t *RxData) {
	uint64_t data;
	TsCoolingLoopsData temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.InverterLoopFluidTemp = CANAL_GET_BITS(data,
            COOLINGLOOPSDATA_INVERTERLOOPFLUIDTEMP_START,
            COOLINGLOOPSDATA_INVERTERLOOPFLUIDTEMP_LENGTH);
            
        temp.MotorLoopFluidTemp = CANAL_GET_BITS(data,
            COOLINGLOOPSDATA_MOTORLOOPFLUIDTEMP_START,
            COOLINGLOOPSDATA_MOTORLOOPFLUIDTEMP_LENGTH);
            
        temp.InverterLoopPressure = CANAL_GET_BITS(data,
            COOLINGLOOPSDATA_INVERTERLOOPPRESSURE_START,
            COOLINGLOOPSDATA_INVERTERLOOPPRESSURE_LENGTH);
            
        temp.MotorLoopPressure = CANAL_GET_BITS(data,
            COOLINGLOOPSDATA_MOTORLOOPPRESSURE_START,
            COOLINGLOOPSDATA_MOTORLOOPPRESSURE_LENGTH);
            
        temp.InverterLoopTempSensorStatus = CANAL_GET_BITS(data,
            COOLINGLOOPSDATA_INVERTERLOOPTEMPSENSORSTATUS_START,
            COOLINGLOOPSDATA_INVERTERLOOPTEMPSENSORSTATUS_LENGTH);
            
        temp.MotorLoopTempSensorStatus = CANAL_GET_BITS(data,
            COOLINGLOOPSDATA_MOTORLOOPTEMPSENSORSTATUS_START,
            COOLINGLOOPSDATA_MOTORLOOPTEMPSENSORSTATUS_LENGTH);
            
        temp.InverterLoopPressureSensorStatus = CANAL_GET_BITS(data,
            COOLINGLOOPSDATA_INVERTERLOOPPRESSURESENSORSTATUS_START,
            COOLINGLOOPSDATA_INVERTERLOOPPRESSURESENSORSTATUS_LENGTH);
            
        temp.MotorLoopPressureSensorStatus = CANAL_GET_BITS(data,
            COOLINGLOOPSDATA_MOTORLOOPPRESSURESENSORSTATUS_START,
            COOLINGLOOPSDATA_MOTORLOOPPRESSURESENSORSTATUS_LENGTH);
            
        temp.MC_CoolingLoopsData = CANAL_GET_BITS(data,
            COOLINGLOOPSDATA_MC_COOLINGLOOPSDATA_START,
            COOLINGLOOPSDATA_MC_COOLINGLOOPSDATA_LENGTH);
            
	//  Apply linear conversion
	temp.InverterLoopFluidTemp = (temp.InverterLoopFluidTemp
			* COOLINGLOOPSDATA_INVERTERLOOPFLUIDTEMP_FACTOR)
			+ COOLINGLOOPSDATA_INVERTERLOOPFLUIDTEMP_OFFSET; 
            
	temp.MotorLoopFluidTemp = (temp.MotorLoopFluidTemp
			* COOLINGLOOPSDATA_MOTORLOOPFLUIDTEMP_FACTOR)
			+ COOLINGLOOPSDATA_MOTORLOOPFLUIDTEMP_OFFSET; 
            
	temp.InverterLoopPressure = (temp.InverterLoopPressure
			* COOLINGLOOPSDATA_INVERTERLOOPPRESSURE_FACTOR)
			+ COOLINGLOOPSDATA_INVERTERLOOPPRESSURE_OFFSET; 
            
	temp.MotorLoopPressure = (temp.MotorLoopPressure
			* COOLINGLOOPSDATA_MOTORLOOPPRESSURE_FACTOR)
			+ COOLINGLOOPSDATA_MOTORLOOPPRESSURE_OFFSET; 
            
	temp.InverterLoopTempSensorStatus = (temp.InverterLoopTempSensorStatus
			* COOLINGLOOPSDATA_INVERTERLOOPTEMPSENSORSTATUS_FACTOR)
			+ COOLINGLOOPSDATA_INVERTERLOOPTEMPSENSORSTATUS_OFFSET; 
            
	temp.MotorLoopTempSensorStatus = (temp.MotorLoopTempSensorStatus
			* COOLINGLOOPSDATA_MOTORLOOPTEMPSENSORSTATUS_FACTOR)
			+ COOLINGLOOPSDATA_MOTORLOOPTEMPSENSORSTATUS_OFFSET; 
            
	temp.InverterLoopPressureSensorStatus = (temp.InverterLoopPressureSensorStatus
			* COOLINGLOOPSDATA_INVERTERLOOPPRESSURESENSORSTATUS_FACTOR)
			+ COOLINGLOOPSDATA_INVERTERLOOPPRESSURESENSORSTATUS_OFFSET; 
            
	temp.MotorLoopPressureSensorStatus = (temp.MotorLoopPressureSensorStatus
			* COOLINGLOOPSDATA_MOTORLOOPPRESSURESENSORSTATUS_FACTOR)
			+ COOLINGLOOPSDATA_MOTORLOOPPRESSURESENSORSTATUS_OFFSET; 
            
	temp.MC_CoolingLoopsData = (temp.MC_CoolingLoopsData
			* COOLINGLOOPSDATA_MC_COOLINGLOOPSDATA_FACTOR)
			+ COOLINGLOOPSDATA_MC_COOLINGLOOPSDATA_OFFSET; 
            
	//  Writing to global struct instance
	CoolingLoopsData = temp;

	return CANAL_OK;
}
TeCanALRet Unmarshal_PedalPositions(uint8_t *RxData) {
	uint64_t data;
	TsPedalPositions temp;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.BrakePedalPosition0 = CANAL_GET_BITS(data,
            PEDALPOSITIONS_BRAKEPEDALPOSITION0_START,
            PEDALPOSITIONS_BRAKEPEDALPOSITION0_LENGTH);
            
        temp.BrakePedalPosition1 = CANAL_GET_BITS(data,
            PEDALPOSITIONS_BRAKEPEDALPOSITION1_START,
            PEDALPOSITIONS_BRAKEPEDALPOSITION1_LENGTH);
            
        temp.AcceleratorPedalPosition1 = CANAL_GET_BITS(data,
            PEDALPOSITIONS_ACCELERATORPEDALPOSITION1_START,
            PEDALPOSITIONS_ACCELERATORPEDALPOSITION1_LENGTH);
            
        temp.AcceleratorPedalPosition0 = CANAL_GET_BITS(data,
            PEDALPOSITIONS_ACCELERATORPEDALPOSITION0_START,
            PEDALPOSITIONS_ACCELERATORPEDALPOSITION0_LENGTH);
            
        temp.DriveButton = CANAL_GET_BITS(data,
            PEDALPOSITIONS_DRIVEBUTTON_START,
            PEDALPOSITIONS_DRIVEBUTTON_LENGTH);
            
        temp.Bpps0Status = CANAL_GET_BITS(data,
            PEDALPOSITIONS_BPPS0STATUS_START,
            PEDALPOSITIONS_BPPS0STATUS_LENGTH);
            
        temp.Bpps1Status = CANAL_GET_BITS(data,
            PEDALPOSITIONS_BPPS1STATUS_START,
            PEDALPOSITIONS_BPPS1STATUS_LENGTH);
            
        temp.Apps0Status = CANAL_GET_BITS(data,
            PEDALPOSITIONS_APPS0STATUS_START,
            PEDALPOSITIONS_APPS0STATUS_LENGTH);
            
        temp.Apps1Status = CANAL_GET_BITS(data,
            PEDALPOSITIONS_APPS1STATUS_START,
            PEDALPOSITIONS_APPS1STATUS_LENGTH);
            
        temp.BspdFault = CANAL_GET_BITS(data,
            PEDALPOSITIONS_BSPDFAULT_START,
            PEDALPOSITIONS_BSPDFAULT_LENGTH);
            
        temp.MC_PedalPosition = CANAL_GET_BITS(data,
            PEDALPOSITIONS_MC_PEDALPOSITION_START,
            PEDALPOSITIONS_MC_PEDALPOSITION_LENGTH);
            
	//  Apply linear conversion
	temp.BrakePedalPosition0 = (temp.BrakePedalPosition0
			* PEDALPOSITIONS_BRAKEPEDALPOSITION0_FACTOR)
			+ PEDALPOSITIONS_BRAKEPEDALPOSITION0_OFFSET; 
            
	temp.BrakePedalPosition1 = (temp.BrakePedalPosition1
			* PEDALPOSITIONS_BRAKEPEDALPOSITION1_FACTOR)
			+ PEDALPOSITIONS_BRAKEPEDALPOSITION1_OFFSET; 
            
	temp.AcceleratorPedalPosition1 = (temp.AcceleratorPedalPosition1
			* PEDALPOSITIONS_ACCELERATORPEDALPOSITION1_FACTOR)
			+ PEDALPOSITIONS_ACCELERATORPEDALPOSITION1_OFFSET; 
            
	temp.AcceleratorPedalPosition0 = (temp.AcceleratorPedalPosition0
			* PEDALPOSITIONS_ACCELERATORPEDALPOSITION0_FACTOR)
			+ PEDALPOSITIONS_ACCELERATORPEDALPOSITION0_OFFSET; 
            
	temp.DriveButton = (temp.DriveButton
			* PEDALPOSITIONS_DRIVEBUTTON_FACTOR)
			+ PEDALPOSITIONS_DRIVEBUTTON_OFFSET; 
            
	temp.Bpps0Status = (temp.Bpps0Status
			* PEDALPOSITIONS_BPPS0STATUS_FACTOR)
			+ PEDALPOSITIONS_BPPS0STATUS_OFFSET; 
            
	temp.Bpps1Status = (temp.Bpps1Status
			* PEDALPOSITIONS_BPPS1STATUS_FACTOR)
			+ PEDALPOSITIONS_BPPS1STATUS_OFFSET; 
            
	temp.Apps0Status = (temp.Apps0Status
			* PEDALPOSITIONS_APPS0STATUS_FACTOR)
			+ PEDALPOSITIONS_APPS0STATUS_OFFSET; 
            
	temp.Apps1Status = (temp.Apps1Status
			* PEDALPOSITIONS_APPS1STATUS_FACTOR)
			+ PEDALPOSITIONS_APPS1STATUS_OFFSET; 
            
	temp.BspdFault = (temp.BspdFault
			* PEDALPOSITIONS_BSPDFAULT_FACTOR)
			+ PEDALPOSITIONS_BSPDFAULT_OFFSET; 
            
	temp.MC_PedalPosition = (temp.MC_PedalPosition
			* PEDALPOSITIONS_MC_PEDALPOSITION_FACTOR)
			+ PEDALPOSITIONS_MC_PEDALPOSITION_OFFSET; 
            
	//  Writing to global struct instance
	PedalPositions = temp;

	return CANAL_OK;
}

TeCanALRet Marshal_AMK1_SetPoints1(uint8_t *TxData) {
	uint64_t dataWord = 0;
	TsAMK1_SetPoints1 temp;
	TeCanALRet ret;

	temp = AMK1_SetPoints1;
    
    // Reverse linear conversion
	temp.AMK_bInverterOn = (temp.AMK_bInverterOn
			- AMK1_SETPOINTS1_AMK_BINVERTERON_OFFSET)
			/ AMK1_SETPOINTS1_AMK_BINVERTERON_FACTOR;
            
	temp.AMK_bDcOn = (temp.AMK_bDcOn
			- AMK1_SETPOINTS1_AMK_BDCON_OFFSET)
			/ AMK1_SETPOINTS1_AMK_BDCON_FACTOR;
            
	temp.AMK_bEnable = (temp.AMK_bEnable
			- AMK1_SETPOINTS1_AMK_BENABLE_OFFSET)
			/ AMK1_SETPOINTS1_AMK_BENABLE_FACTOR;
            
	temp.AMK_bErrorReset = (temp.AMK_bErrorReset
			- AMK1_SETPOINTS1_AMK_BERRORRESET_OFFSET)
			/ AMK1_SETPOINTS1_AMK_BERRORRESET_FACTOR;
            
	temp.AMK_TargetVelocity = (temp.AMK_TargetVelocity
			- AMK1_SETPOINTS1_AMK_TARGETVELOCITY_OFFSET)
			/ AMK1_SETPOINTS1_AMK_TARGETVELOCITY_FACTOR;
            
	temp.AMK_TorqueLimitPositiv = (temp.AMK_TorqueLimitPositiv
			- AMK1_SETPOINTS1_AMK_TORQUELIMITPOSITIV_OFFSET)
			/ AMK1_SETPOINTS1_AMK_TORQUELIMITPOSITIV_FACTOR;
            
	temp.AMK_TorqueLimitNegativ = (temp.AMK_TorqueLimitNegativ
			- AMK1_SETPOINTS1_AMK_TORQUELIMITNEGATIV_OFFSET)
			/ AMK1_SETPOINTS1_AMK_TORQUELIMITNEGATIV_FACTOR;
            
    // CANAL_SET_BITS only writes to correct bits, dataWord is not being overwritten
	dataWord = CANAL_SET_BITS(temp.AMK_bInverterOn, dataWord,
            //little_endian
            AMK1_SETPOINTS1_AMK_BINVERTERON_START,
			AMK1_SETPOINTS1_AMK_BINVERTERON_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_bDcOn, dataWord,
            //little_endian
            AMK1_SETPOINTS1_AMK_BDCON_START,
			AMK1_SETPOINTS1_AMK_BDCON_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_bEnable, dataWord,
            //little_endian
            AMK1_SETPOINTS1_AMK_BENABLE_START,
			AMK1_SETPOINTS1_AMK_BENABLE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_bErrorReset, dataWord,
            //little_endian
            AMK1_SETPOINTS1_AMK_BERRORRESET_START,
			AMK1_SETPOINTS1_AMK_BERRORRESET_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_TargetVelocity, dataWord,
            //little_endian
            AMK1_SETPOINTS1_AMK_TARGETVELOCITY_START,
			AMK1_SETPOINTS1_AMK_TARGETVELOCITY_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_TorqueLimitPositiv, dataWord,
            //little_endian
            AMK1_SETPOINTS1_AMK_TORQUELIMITPOSITIV_START,
			AMK1_SETPOINTS1_AMK_TORQUELIMITPOSITIV_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_TorqueLimitNegativ, dataWord,
            //little_endian
            AMK1_SETPOINTS1_AMK_TORQUELIMITNEGATIV_START,
			AMK1_SETPOINTS1_AMK_TORQUELIMITNEGATIV_LENGTH);
            
	setDataWordIntoByteArray(dataWord, TxData);

	return CANAL_OK;
}
TeCanALRet Marshal_AMK0_SetPoints1(uint8_t *TxData) {
	uint64_t dataWord = 0;
	TsAMK0_SetPoints1 temp;
	TeCanALRet ret;

	temp = AMK0_SetPoints1;
    
    // Reverse linear conversion
	temp.AMK_bInverterOn = (temp.AMK_bInverterOn
			- AMK0_SETPOINTS1_AMK_BINVERTERON_OFFSET)
			/ AMK0_SETPOINTS1_AMK_BINVERTERON_FACTOR;
            
	temp.AMK_bDcOn = (temp.AMK_bDcOn
			- AMK0_SETPOINTS1_AMK_BDCON_OFFSET)
			/ AMK0_SETPOINTS1_AMK_BDCON_FACTOR;
            
	temp.AMK_bEnable = (temp.AMK_bEnable
			- AMK0_SETPOINTS1_AMK_BENABLE_OFFSET)
			/ AMK0_SETPOINTS1_AMK_BENABLE_FACTOR;
            
	temp.AMK_bErrorReset = (temp.AMK_bErrorReset
			- AMK0_SETPOINTS1_AMK_BERRORRESET_OFFSET)
			/ AMK0_SETPOINTS1_AMK_BERRORRESET_FACTOR;
            
	temp.AMK_TargetVelocity = (temp.AMK_TargetVelocity
			- AMK0_SETPOINTS1_AMK_TARGETVELOCITY_OFFSET)
			/ AMK0_SETPOINTS1_AMK_TARGETVELOCITY_FACTOR;
            
	temp.AMK_TorqueLimitPositiv = (temp.AMK_TorqueLimitPositiv
			- AMK0_SETPOINTS1_AMK_TORQUELIMITPOSITIV_OFFSET)
			/ AMK0_SETPOINTS1_AMK_TORQUELIMITPOSITIV_FACTOR;
            
	temp.AMK_TorqueLimitNegativ = (temp.AMK_TorqueLimitNegativ
			- AMK0_SETPOINTS1_AMK_TORQUELIMITNEGATIV_OFFSET)
			/ AMK0_SETPOINTS1_AMK_TORQUELIMITNEGATIV_FACTOR;
            
    // CANAL_SET_BITS only writes to correct bits, dataWord is not being overwritten
	dataWord = CANAL_SET_BITS(temp.AMK_bInverterOn, dataWord,
            //little_endian
            AMK0_SETPOINTS1_AMK_BINVERTERON_START,
			AMK0_SETPOINTS1_AMK_BINVERTERON_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_bDcOn, dataWord,
            //little_endian
            AMK0_SETPOINTS1_AMK_BDCON_START,
			AMK0_SETPOINTS1_AMK_BDCON_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_bEnable, dataWord,
            //little_endian
            AMK0_SETPOINTS1_AMK_BENABLE_START,
			AMK0_SETPOINTS1_AMK_BENABLE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_bErrorReset, dataWord,
            //little_endian
            AMK0_SETPOINTS1_AMK_BERRORRESET_START,
			AMK0_SETPOINTS1_AMK_BERRORRESET_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_TargetVelocity, dataWord,
            //little_endian
            AMK0_SETPOINTS1_AMK_TARGETVELOCITY_START,
			AMK0_SETPOINTS1_AMK_TARGETVELOCITY_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_TorqueLimitPositiv, dataWord,
            //little_endian
            AMK0_SETPOINTS1_AMK_TORQUELIMITPOSITIV_START,
			AMK0_SETPOINTS1_AMK_TORQUELIMITPOSITIV_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.AMK_TorqueLimitNegativ, dataWord,
            //little_endian
            AMK0_SETPOINTS1_AMK_TORQUELIMITNEGATIV_START,
			AMK0_SETPOINTS1_AMK_TORQUELIMITNEGATIV_LENGTH);
            
	setDataWordIntoByteArray(dataWord, TxData);

	return CANAL_OK;
}
TeCanALRet Marshal_VehicleInfo(uint8_t *TxData) {
	uint64_t dataWord = 0;
	TsVehicleInfo temp;
	TeCanALRet ret;

	temp = VehicleInfo;
    
    // Reverse linear conversion
	temp.MaximumPowerAvailablePercentage = (temp.MaximumPowerAvailablePercentage
			- VEHICLEINFO_MAXIMUMPOWERAVAILABLEPERCENTAGE_OFFSET)
			/ VEHICLEINFO_MAXIMUMPOWERAVAILABLEPERCENTAGE_FACTOR;
            
	temp.SocPercentage = (temp.SocPercentage
			- VEHICLEINFO_SOCPERCENTAGE_OFFSET)
			/ VEHICLEINFO_SOCPERCENTAGE_FACTOR;
            
	temp.VcuErrors = (temp.VcuErrors
			- VEHICLEINFO_VCUERRORS_OFFSET)
			/ VEHICLEINFO_VCUERRORS_FACTOR;
            
	temp.VehicleSpeed = (temp.VehicleSpeed
			- VEHICLEINFO_VEHICLESPEED_OFFSET)
			/ VEHICLEINFO_VEHICLESPEED_FACTOR;
            
	temp.VehicleStatus = (temp.VehicleStatus
			- VEHICLEINFO_VEHICLESTATUS_OFFSET)
			/ VEHICLEINFO_VEHICLESTATUS_FACTOR;
            
    // CANAL_SET_BITS only writes to correct bits, dataWord is not being overwritten
	dataWord = CANAL_SET_BITS(temp.MaximumPowerAvailablePercentage, dataWord,
            //little_endian
            VEHICLEINFO_MAXIMUMPOWERAVAILABLEPERCENTAGE_START,
			VEHICLEINFO_MAXIMUMPOWERAVAILABLEPERCENTAGE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.SocPercentage, dataWord,
            //little_endian
            VEHICLEINFO_SOCPERCENTAGE_START,
			VEHICLEINFO_SOCPERCENTAGE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.VcuErrors, dataWord,
            //little_endian
            VEHICLEINFO_VCUERRORS_START,
			VEHICLEINFO_VCUERRORS_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.VehicleSpeed, dataWord,
            //little_endian
            VEHICLEINFO_VEHICLESPEED_START,
			VEHICLEINFO_VEHICLESPEED_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.VehicleStatus, dataWord,
            //little_endian
            VEHICLEINFO_VEHICLESTATUS_START,
			VEHICLEINFO_VEHICLESTATUS_LENGTH);
            
	setDataWordIntoByteArray(dataWord, TxData);

	return CANAL_OK;
}
TeCanALRet Marshal_PiuControllerQuestion(uint8_t *TxData) {
	uint64_t dataWord = 0;
	TsPiuControllerQuestion temp;
	TeCanALRet ret;

	temp = PiuControllerQuestion;
    
    // Reverse linear conversion
	temp.PiuQuestion = (temp.PiuQuestion
			- PIUCONTROLLERQUESTION_PIUQUESTION_OFFSET)
			/ PIUCONTROLLERQUESTION_PIUQUESTION_FACTOR;
            
    // CANAL_SET_BITS only writes to correct bits, dataWord is not being overwritten
	dataWord = CANAL_SET_BITS(temp.PiuQuestion, dataWord,
            //little_endian
            PIUCONTROLLERQUESTION_PIUQUESTION_START,
			PIUCONTROLLERQUESTION_PIUQUESTION_LENGTH);
            
	setDataWordIntoByteArray(dataWord, TxData);

	return CANAL_OK;
}
TeCanALRet Marshal_DashboardQuestion(uint8_t *TxData) {
	uint64_t dataWord = 0;
	TsDashboardQuestion temp;
	TeCanALRet ret;

	temp = DashboardQuestion;
    
    // Reverse linear conversion
	temp.DcuQuestion = (temp.DcuQuestion
			- DASHBOARDQUESTION_DCUQUESTION_OFFSET)
			/ DASHBOARDQUESTION_DCUQUESTION_FACTOR;
            
    // CANAL_SET_BITS only writes to correct bits, dataWord is not being overwritten
	dataWord = CANAL_SET_BITS(temp.DcuQuestion, dataWord,
            //little_endian
            DASHBOARDQUESTION_DCUQUESTION_START,
			DASHBOARDQUESTION_DCUQUESTION_LENGTH);
            
	setDataWordIntoByteArray(dataWord, TxData);

	return CANAL_OK;
}
TeCanALRet Marshal_CoolingControllerQuestion(uint8_t *TxData) {
	uint64_t dataWord = 0;
	TsCoolingControllerQuestion temp;
	TeCanALRet ret;

	temp = CoolingControllerQuestion;
    
    // Reverse linear conversion
	temp.CcuQuestion = (temp.CcuQuestion
			- COOLINGCONTROLLERQUESTION_CCUQUESTION_OFFSET)
			/ COOLINGCONTROLLERQUESTION_CCUQUESTION_FACTOR;
            
    // CANAL_SET_BITS only writes to correct bits, dataWord is not being overwritten
	dataWord = CANAL_SET_BITS(temp.CcuQuestion, dataWord,
            //little_endian
            COOLINGCONTROLLERQUESTION_CCUQUESTION_START,
			COOLINGCONTROLLERQUESTION_CCUQUESTION_LENGTH);
            
	setDataWordIntoByteArray(dataWord, TxData);

	return CANAL_OK;
}
TeCanALRet Marshal_TemperatureInfo(uint8_t *TxData) {
	uint64_t dataWord = 0;
	TsTemperatureInfo temp;
	TeCanALRet ret;

	temp = TemperatureInfo;
    
    // Reverse linear conversion
	temp.LeftFrontMotorTemperature = (temp.LeftFrontMotorTemperature
			- TEMPERATUREINFO_LEFTFRONTMOTORTEMPERATURE_OFFSET)
			/ TEMPERATUREINFO_LEFTFRONTMOTORTEMPERATURE_FACTOR;
            
	temp.LeftRearMotorTemperature = (temp.LeftRearMotorTemperature
			- TEMPERATUREINFO_LEFTREARMOTORTEMPERATURE_OFFSET)
			/ TEMPERATUREINFO_LEFTREARMOTORTEMPERATURE_FACTOR;
            
	temp.RightFrontMotorTemperature = (temp.RightFrontMotorTemperature
			- TEMPERATUREINFO_RIGHTFRONTMOTORTEMPERATURE_OFFSET)
			/ TEMPERATUREINFO_RIGHTFRONTMOTORTEMPERATURE_FACTOR;
            
	temp.RightRearMotorTemperature = (temp.RightRearMotorTemperature
			- TEMPERATUREINFO_RIGHTREARMOTORTEMPERATURE_OFFSET)
			/ TEMPERATUREINFO_RIGHTREARMOTORTEMPERATURE_FACTOR;
            
	temp.BatteryTemperature = (temp.BatteryTemperature
			- TEMPERATUREINFO_BATTERYTEMPERATURE_OFFSET)
			/ TEMPERATUREINFO_BATTERYTEMPERATURE_FACTOR;
            
    // CANAL_SET_BITS only writes to correct bits, dataWord is not being overwritten
	dataWord = CANAL_SET_BITS(temp.LeftFrontMotorTemperature, dataWord,
            //little_endian
            TEMPERATUREINFO_LEFTFRONTMOTORTEMPERATURE_START,
			TEMPERATUREINFO_LEFTFRONTMOTORTEMPERATURE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.LeftRearMotorTemperature, dataWord,
            //little_endian
            TEMPERATUREINFO_LEFTREARMOTORTEMPERATURE_START,
			TEMPERATUREINFO_LEFTREARMOTORTEMPERATURE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.RightFrontMotorTemperature, dataWord,
            //little_endian
            TEMPERATUREINFO_RIGHTFRONTMOTORTEMPERATURE_START,
			TEMPERATUREINFO_RIGHTFRONTMOTORTEMPERATURE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.RightRearMotorTemperature, dataWord,
            //little_endian
            TEMPERATUREINFO_RIGHTREARMOTORTEMPERATURE_START,
			TEMPERATUREINFO_RIGHTREARMOTORTEMPERATURE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.BatteryTemperature, dataWord,
            //little_endian
            TEMPERATUREINFO_BATTERYTEMPERATURE_START,
			TEMPERATUREINFO_BATTERYTEMPERATURE_LENGTH);
            
	setDataWordIntoByteArray(dataWord, TxData);

	return CANAL_OK;
}
TeCanALRet Marshal_CoolingLoopModes(uint8_t *TxData) {
	uint64_t dataWord = 0;
	TsCoolingLoopModes temp;
	TeCanALRet ret;

	temp = CoolingLoopModes;
    
    // Reverse linear conversion
	temp.InverterLoopFanMode = (temp.InverterLoopFanMode
			- COOLINGLOOPMODES_INVERTERLOOPFANMODE_OFFSET)
			/ COOLINGLOOPMODES_INVERTERLOOPFANMODE_FACTOR;
            
	temp.InverterLoopPumpMode = (temp.InverterLoopPumpMode
			- COOLINGLOOPMODES_INVERTERLOOPPUMPMODE_OFFSET)
			/ COOLINGLOOPMODES_INVERTERLOOPPUMPMODE_FACTOR;
            
	temp.SpeakerRequest = (temp.SpeakerRequest
			- COOLINGLOOPMODES_SPEAKERREQUEST_OFFSET)
			/ COOLINGLOOPMODES_SPEAKERREQUEST_FACTOR;
            
	temp.MotorLoopFanMode = (temp.MotorLoopFanMode
			- COOLINGLOOPMODES_MOTORLOOPFANMODE_OFFSET)
			/ COOLINGLOOPMODES_MOTORLOOPFANMODE_FACTOR;
            
	temp.MotorLoopPumpMode = (temp.MotorLoopPumpMode
			- COOLINGLOOPMODES_MOTORLOOPPUMPMODE_OFFSET)
			/ COOLINGLOOPMODES_MOTORLOOPPUMPMODE_FACTOR;
            
    // CANAL_SET_BITS only writes to correct bits, dataWord is not being overwritten
	dataWord = CANAL_SET_BITS(temp.InverterLoopFanMode, dataWord,
            //little_endian
            COOLINGLOOPMODES_INVERTERLOOPFANMODE_START,
			COOLINGLOOPMODES_INVERTERLOOPFANMODE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.InverterLoopPumpMode, dataWord,
            //little_endian
            COOLINGLOOPMODES_INVERTERLOOPPUMPMODE_START,
			COOLINGLOOPMODES_INVERTERLOOPPUMPMODE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.SpeakerRequest, dataWord,
            //little_endian
            COOLINGLOOPMODES_SPEAKERREQUEST_START,
			COOLINGLOOPMODES_SPEAKERREQUEST_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.MotorLoopFanMode, dataWord,
            //little_endian
            COOLINGLOOPMODES_MOTORLOOPFANMODE_START,
			COOLINGLOOPMODES_MOTORLOOPFANMODE_LENGTH);
            
	dataWord = CANAL_SET_BITS(temp.MotorLoopPumpMode, dataWord,
            //little_endian
            COOLINGLOOPMODES_MOTORLOOPPUMPMODE_START,
			COOLINGLOOPMODES_MOTORLOOPPUMPMODE_LENGTH);
            
	setDataWordIntoByteArray(dataWord, TxData);

	return CANAL_OK;
}

/*********************************************************
 *               FUNCTION POINTER TABLE
 *********************************************************/

static const struct {
	TeMessageID ID;
	BinaryUnmarshaller *Unmarshal;
} CANAL_RX_MESSAGE_TABLE[NUM_RX_MESSAGES] = {
	{ AMK1_ACTUALVALUES2_CANAL_ID,           &Unmarshal_AMK1_ActualValues2 },
	{ AMK1_ACTUALVALUES1_CANAL_ID,           &Unmarshal_AMK1_ActualValues1 },
	{ AMK0_ACTUALVALUES1_CANAL_ID,           &Unmarshal_AMK0_ActualValues1 },
	{ AMK0_ACTUALVALUES2_CANAL_ID,           &Unmarshal_AMK0_ActualValues2 },
	{ ACCELEROMETERDATA_CANAL_ID,            &Unmarshal_AccelerometerData },
	{ LVBATTERYDATA_CANAL_ID,                &Unmarshal_LvBatteryData },
	{ COOLINGCONTROLLERANSWER_CANAL_ID,      &Unmarshal_CoolingControllerAnswer },
	{ DASHBOARDANSWER_CANAL_ID,              &Unmarshal_DashboardAnswer },
	{ PIUCONTROLLERANSWER_CANAL_ID,          &Unmarshal_PiuControllerAnswer },
	{ DASHBOARDDATA_CANAL_ID,                &Unmarshal_DashboardData },
	{ COOLINGLOOPSDATA_CANAL_ID,             &Unmarshal_CoolingLoopsData },
	{ PEDALPOSITIONS_CANAL_ID,               &Unmarshal_PedalPositions },
};

static const struct {
	TeMessageID ID;
	BinaryMarshaller *Marshal;
    uint32_t dlc;
} CANAL_TX_MESSAGE_TABLE[NUM_TX_MESSAGES] = {
	{ AMK1_SETPOINTS1_CANAL_ID,              &Marshal_AMK1_SetPoints1,              AMK1_SETPOINTS1_DATA_LENGTH },
	{ AMK0_SETPOINTS1_CANAL_ID,              &Marshal_AMK0_SetPoints1,              AMK0_SETPOINTS1_DATA_LENGTH },
	{ VEHICLEINFO_CANAL_ID,                  &Marshal_VehicleInfo,                  VEHICLEINFO_DATA_LENGTH },
	{ PIUCONTROLLERQUESTION_CANAL_ID,        &Marshal_PiuControllerQuestion,        PIUCONTROLLERQUESTION_DATA_LENGTH },
	{ DASHBOARDQUESTION_CANAL_ID,            &Marshal_DashboardQuestion,            DASHBOARDQUESTION_DATA_LENGTH },
	{ COOLINGCONTROLLERQUESTION_CANAL_ID,    &Marshal_CoolingControllerQuestion,    COOLINGCONTROLLERQUESTION_DATA_LENGTH },
	{ TEMPERATUREINFO_CANAL_ID,              &Marshal_TemperatureInfo,              TEMPERATUREINFO_DATA_LENGTH },
	{ COOLINGLOOPMODES_CANAL_ID,             &Marshal_CoolingLoopModes,             COOLINGLOOPMODES_DATA_LENGTH },
};

static const struct {
	TeMessageID ID;
	CanALPrinter* printer;
} CANAL_PRINTER_TABLE[TOTAL_MESSAGES] = {
	{ AMK1_SETPOINTS1_CANAL_ID,              &Print_AMK1_SetPoints1 },
	{ AMK1_ACTUALVALUES2_CANAL_ID,           &Print_AMK1_ActualValues2 },
	{ AMK1_ACTUALVALUES1_CANAL_ID,           &Print_AMK1_ActualValues1 },
	{ AMK0_ACTUALVALUES1_CANAL_ID,           &Print_AMK0_ActualValues1 },
	{ AMK0_ACTUALVALUES2_CANAL_ID,           &Print_AMK0_ActualValues2 },
	{ AMK0_SETPOINTS1_CANAL_ID,              &Print_AMK0_SetPoints1 },
	{ ACCELEROMETERDATA_CANAL_ID,            &Print_AccelerometerData },
	{ LVBATTERYDATA_CANAL_ID,                &Print_LvBatteryData },
	{ VEHICLEINFO_CANAL_ID,                  &Print_VehicleInfo },
	{ COOLINGCONTROLLERANSWER_CANAL_ID,      &Print_CoolingControllerAnswer },
	{ DASHBOARDANSWER_CANAL_ID,              &Print_DashboardAnswer },
	{ PIUCONTROLLERANSWER_CANAL_ID,          &Print_PiuControllerAnswer },
	{ PIUCONTROLLERQUESTION_CANAL_ID,        &Print_PiuControllerQuestion },
	{ DASHBOARDQUESTION_CANAL_ID,            &Print_DashboardQuestion },
	{ COOLINGCONTROLLERQUESTION_CANAL_ID,    &Print_CoolingControllerQuestion },
	{ DASHBOARDDATA_CANAL_ID,                &Print_DashboardData },
	{ TEMPERATUREINFO_CANAL_ID,              &Print_TemperatureInfo },
	{ COOLINGLOOPSDATA_CANAL_ID,             &Print_CoolingLoopsData },
	{ COOLINGLOOPMODES_CANAL_ID,             &Print_CoolingLoopModes },
	{ PEDALPOSITIONS_CANAL_ID,               &Print_PedalPositions },
};

/*********************************************************
 *           FUNCTION POINTER TABLE GETTERS
 *********************************************************/

 static TeCanALRet getBinaryUnmarshaller(uint32_t *ID, BinaryUnmarshaller **pUnmarshal) {
	for (int i = 0; i < NUM_RX_MESSAGES; i++) {
		if ((*ID) == CANAL_RX_MESSAGE_TABLE[i].ID) {
			*pUnmarshal = CANAL_RX_MESSAGE_TABLE[i].Unmarshal;

			return CANAL_OK;
		}
	}

	return CANAL_UNSUPPORTED_RX_MESSAGE;
}

static TeCanALRet getBinaryMarshaller(TeMessageID *ID, BinaryMarshaller **pMarshal) {
	for (int i = 0; i < NUM_TX_MESSAGES; i++) {
		if ((*ID) == CANAL_TX_MESSAGE_TABLE[i].ID) {
			*pMarshal = CANAL_TX_MESSAGE_TABLE[i].Marshal;

			return CANAL_OK;
		}
	}

	return CANAL_UNSUPPORTED_TX_MESSAGE;
}

/*********************************************************
 *             PUBLIC FUNCTION DEFINITIONS
 *********************************************************/
 
void Print_AMK1_SetPoints1() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: AMK1_SetPoints1");
    CANAL_PRINT("%sAMK_bInverterOn: %u", sep, AMK1_SetPoints1.AMK_bInverterOn);
    CANAL_PRINT("%sAMK_bDcOn: %u", sep, AMK1_SetPoints1.AMK_bDcOn);
    CANAL_PRINT("%sAMK_bEnable: %u", sep, AMK1_SetPoints1.AMK_bEnable);
    CANAL_PRINT("%sAMK_bErrorReset: %u", sep, AMK1_SetPoints1.AMK_bErrorReset);
    CANAL_PRINT("%sAMK_TargetVelocity: %f", sep, AMK1_SetPoints1.AMK_TargetVelocity);
    CANAL_PRINT("%sAMK_TorqueLimitPositiv: %f", sep, AMK1_SetPoints1.AMK_TorqueLimitPositiv);
    CANAL_PRINT("%sAMK_TorqueLimitNegativ: %f", sep, AMK1_SetPoints1.AMK_TorqueLimitNegativ);
    CANAL_PRINT("\n\r");
}
void Print_AMK1_ActualValues2() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: AMK1_ActualValues2");
    CANAL_PRINT("%sAMK_TempMotor: %f", sep, AMK1_ActualValues2.AMK_TempMotor);
    CANAL_PRINT("%sAMK_TempInverter: %f", sep, AMK1_ActualValues2.AMK_TempInverter);
    CANAL_PRINT("%sAMK_ErrorInfo: %u", sep, AMK1_ActualValues2.AMK_ErrorInfo);
    CANAL_PRINT("%sAMK_TempIGBT: %f", sep, AMK1_ActualValues2.AMK_TempIGBT);
    CANAL_PRINT("\n\r");
}
void Print_AMK1_ActualValues1() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: AMK1_ActualValues1");
    CANAL_PRINT("%sAMK_bSystemReady: %u", sep, AMK1_ActualValues1.AMK_bSystemReady);
    CANAL_PRINT("%sAMK_bError: %u", sep, AMK1_ActualValues1.AMK_bError);
    CANAL_PRINT("%sAMK_bWarn: %u", sep, AMK1_ActualValues1.AMK_bWarn);
    CANAL_PRINT("%sAMK_bQuitDcOn: %u", sep, AMK1_ActualValues1.AMK_bQuitDcOn);
    CANAL_PRINT("%sAMK_bDcOn: %u", sep, AMK1_ActualValues1.AMK_bDcOn);
    CANAL_PRINT("%sAMK_bQuitInverterOn: %u", sep, AMK1_ActualValues1.AMK_bQuitInverterOn);
    CANAL_PRINT("%sAMK_bInverterOn: %u", sep, AMK1_ActualValues1.AMK_bInverterOn);
    CANAL_PRINT("%sAMK_bDerating: %u", sep, AMK1_ActualValues1.AMK_bDerating);
    CANAL_PRINT("%sAMK_ActualVelocity: %f", sep, AMK1_ActualValues1.AMK_ActualVelocity);
    CANAL_PRINT("%sAMK_TorqueCurrent: %f", sep, AMK1_ActualValues1.AMK_TorqueCurrent);
    CANAL_PRINT("%sAMK_MagnetizingCurrent: %f", sep, AMK1_ActualValues1.AMK_MagnetizingCurrent);
    CANAL_PRINT("\n\r");
}
void Print_AMK0_ActualValues1() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: AMK0_ActualValues1");
    CANAL_PRINT("%sAMK_bSystemReady: %u", sep, AMK0_ActualValues1.AMK_bSystemReady);
    CANAL_PRINT("%sAMK_bError: %u", sep, AMK0_ActualValues1.AMK_bError);
    CANAL_PRINT("%sAMK_bWarn: %u", sep, AMK0_ActualValues1.AMK_bWarn);
    CANAL_PRINT("%sAMK_bQuitDcOn: %u", sep, AMK0_ActualValues1.AMK_bQuitDcOn);
    CANAL_PRINT("%sAMK_bDcOn: %u", sep, AMK0_ActualValues1.AMK_bDcOn);
    CANAL_PRINT("%sAMK_bQuitInverterOn: %u", sep, AMK0_ActualValues1.AMK_bQuitInverterOn);
    CANAL_PRINT("%sAMK_bInverterOn: %u", sep, AMK0_ActualValues1.AMK_bInverterOn);
    CANAL_PRINT("%sAMK_bDerating: %u", sep, AMK0_ActualValues1.AMK_bDerating);
    CANAL_PRINT("%sAMK_ActualVelocity: %f", sep, AMK0_ActualValues1.AMK_ActualVelocity);
    CANAL_PRINT("%sAMK_TorqueCurrent: %f", sep, AMK0_ActualValues1.AMK_TorqueCurrent);
    CANAL_PRINT("%sAMK_MagnetizingCurrent: %f", sep, AMK0_ActualValues1.AMK_MagnetizingCurrent);
    CANAL_PRINT("\n\r");
}
void Print_AMK0_ActualValues2() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: AMK0_ActualValues2");
    CANAL_PRINT("%sAMK_TempMotor: %f", sep, AMK0_ActualValues2.AMK_TempMotor);
    CANAL_PRINT("%sAMK_TempInverter: %f", sep, AMK0_ActualValues2.AMK_TempInverter);
    CANAL_PRINT("%sAMK_ErrorInfo: %u", sep, AMK0_ActualValues2.AMK_ErrorInfo);
    CANAL_PRINT("%sAMK_TempIGBT: %f", sep, AMK0_ActualValues2.AMK_TempIGBT);
    CANAL_PRINT("\n\r");
}
void Print_AMK0_SetPoints1() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: AMK0_SetPoints1");
    CANAL_PRINT("%sAMK_bInverterOn: %u", sep, AMK0_SetPoints1.AMK_bInverterOn);
    CANAL_PRINT("%sAMK_bDcOn: %u", sep, AMK0_SetPoints1.AMK_bDcOn);
    CANAL_PRINT("%sAMK_bEnable: %u", sep, AMK0_SetPoints1.AMK_bEnable);
    CANAL_PRINT("%sAMK_bErrorReset: %u", sep, AMK0_SetPoints1.AMK_bErrorReset);
    CANAL_PRINT("%sAMK_TargetVelocity: %f", sep, AMK0_SetPoints1.AMK_TargetVelocity);
    CANAL_PRINT("%sAMK_TorqueLimitPositiv: %f", sep, AMK0_SetPoints1.AMK_TorqueLimitPositiv);
    CANAL_PRINT("%sAMK_TorqueLimitNegativ: %f", sep, AMK0_SetPoints1.AMK_TorqueLimitNegativ);
    CANAL_PRINT("\n\r");
}
void Print_AccelerometerData() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: AccelerometerData");
    CANAL_PRINT("%sAccelLateral: %d", sep, AccelerometerData.AccelLateral);
    CANAL_PRINT("%sAccelLongitudinal: %d", sep, AccelerometerData.AccelLongitudinal);
    CANAL_PRINT("%sYawRate: %d", sep, AccelerometerData.YawRate);
    CANAL_PRINT("\n\r");
}
void Print_LvBatteryData() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: LvBatteryData");
    CANAL_PRINT("%sGlvCurrent: %u", sep, LvBatteryData.GlvCurrent);
    CANAL_PRINT("%sGlvVoltage: %u", sep, LvBatteryData.GlvVoltage);
    CANAL_PRINT("\n\r");
}
void Print_VehicleInfo() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: VehicleInfo");
    CANAL_PRINT("%sMaximumPowerAvailablePercentage: %u", sep, VehicleInfo.MaximumPowerAvailablePercentage);
    CANAL_PRINT("%sSocPercentage: %u", sep, VehicleInfo.SocPercentage);
    CANAL_PRINT("%sVcuErrors: %u", sep, VehicleInfo.VcuErrors);
    CANAL_PRINT("%sVehicleSpeed: %u", sep, VehicleInfo.VehicleSpeed);
    CANAL_PRINT("%sVehicleStatus: %u", sep, VehicleInfo.VehicleStatus);
    CANAL_PRINT("\n\r");
}
void Print_CoolingControllerAnswer() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: CoolingControllerAnswer");
    CANAL_PRINT("%sCcuAnswer: %u", sep, CoolingControllerAnswer.CcuAnswer);
    CANAL_PRINT("\n\r");
}
void Print_DashboardAnswer() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: DashboardAnswer");
    CANAL_PRINT("%sDcuAnswer: %u", sep, DashboardAnswer.DcuAnswer);
    CANAL_PRINT("\n\r");
}
void Print_PiuControllerAnswer() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: PiuControllerAnswer");
    CANAL_PRINT("%sPiuAnswer: %u", sep, PiuControllerAnswer.PiuAnswer);
    CANAL_PRINT("\n\r");
}
void Print_PiuControllerQuestion() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: PiuControllerQuestion");
    CANAL_PRINT("%sPiuQuestion: %u", sep, PiuControllerQuestion.PiuQuestion);
    CANAL_PRINT("\n\r");
}
void Print_DashboardQuestion() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: DashboardQuestion");
    CANAL_PRINT("%sDcuQuestion: %u", sep, DashboardQuestion.DcuQuestion);
    CANAL_PRINT("\n\r");
}
void Print_CoolingControllerQuestion() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: CoolingControllerQuestion");
    CANAL_PRINT("%sCcuQuestion: %u", sep, CoolingControllerQuestion.CcuQuestion);
    CANAL_PRINT("\n\r");
}
void Print_DashboardData() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: DashboardData");
    CANAL_PRINT("%sGpsVehicleSpeed: %f", sep, DashboardData.GpsVehicleSpeed);
    CANAL_PRINT("\n\r");
}
void Print_TemperatureInfo() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: TemperatureInfo");
    CANAL_PRINT("%sLeftFrontMotorTemperature: %u", sep, TemperatureInfo.LeftFrontMotorTemperature);
    CANAL_PRINT("%sLeftRearMotorTemperature: %u", sep, TemperatureInfo.LeftRearMotorTemperature);
    CANAL_PRINT("%sRightFrontMotorTemperature: %u", sep, TemperatureInfo.RightFrontMotorTemperature);
    CANAL_PRINT("%sRightRearMotorTemperature: %u", sep, TemperatureInfo.RightRearMotorTemperature);
    CANAL_PRINT("%sBatteryTemperature: %u", sep, TemperatureInfo.BatteryTemperature);
    CANAL_PRINT("\n\r");
}
void Print_CoolingLoopsData() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: CoolingLoopsData");
    CANAL_PRINT("%sInverterLoopFluidTemp: %u", sep, CoolingLoopsData.InverterLoopFluidTemp);
    CANAL_PRINT("%sMotorLoopFluidTemp: %u", sep, CoolingLoopsData.MotorLoopFluidTemp);
    CANAL_PRINT("%sInverterLoopPressure: %u", sep, CoolingLoopsData.InverterLoopPressure);
    CANAL_PRINT("%sMotorLoopPressure: %u", sep, CoolingLoopsData.MotorLoopPressure);
    CANAL_PRINT("%sInverterLoopTempSensorStatus: %u", sep, CoolingLoopsData.InverterLoopTempSensorStatus);
    CANAL_PRINT("%sMotorLoopTempSensorStatus: %u", sep, CoolingLoopsData.MotorLoopTempSensorStatus);
    CANAL_PRINT("%sInverterLoopPressureSensorStatus: %u", sep, CoolingLoopsData.InverterLoopPressureSensorStatus);
    CANAL_PRINT("%sMotorLoopPressureSensorStatus: %u", sep, CoolingLoopsData.MotorLoopPressureSensorStatus);
    CANAL_PRINT("%sMC_CoolingLoopsData: %u", sep, CoolingLoopsData.MC_CoolingLoopsData);
    CANAL_PRINT("\n\r");
}
void Print_CoolingLoopModes() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: CoolingLoopModes");
    CANAL_PRINT("%sInverterLoopFanMode: %u", sep, CoolingLoopModes.InverterLoopFanMode);
    CANAL_PRINT("%sInverterLoopPumpMode: %u", sep, CoolingLoopModes.InverterLoopPumpMode);
    CANAL_PRINT("%sSpeakerRequest: %u", sep, CoolingLoopModes.SpeakerRequest);
    CANAL_PRINT("%sMotorLoopFanMode: %u", sep, CoolingLoopModes.MotorLoopFanMode);
    CANAL_PRINT("%sMotorLoopPumpMode: %u", sep, CoolingLoopModes.MotorLoopPumpMode);
    CANAL_PRINT("\n\r");
}
void Print_PedalPositions() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: PedalPositions");
    CANAL_PRINT("%sBrakePedalPosition0: %u", sep, PedalPositions.BrakePedalPosition0);
    CANAL_PRINT("%sBrakePedalPosition1: %u", sep, PedalPositions.BrakePedalPosition1);
    CANAL_PRINT("%sAcceleratorPedalPosition1: %u", sep, PedalPositions.AcceleratorPedalPosition1);
    CANAL_PRINT("%sAcceleratorPedalPosition0: %u", sep, PedalPositions.AcceleratorPedalPosition0);
    CANAL_PRINT("%sDriveButton: %u", sep, PedalPositions.DriveButton);
    CANAL_PRINT("%sBpps0Status: %u", sep, PedalPositions.Bpps0Status);
    CANAL_PRINT("%sBpps1Status: %u", sep, PedalPositions.Bpps1Status);
    CANAL_PRINT("%sApps0Status: %u", sep, PedalPositions.Apps0Status);
    CANAL_PRINT("%sApps1Status: %u", sep, PedalPositions.Apps1Status);
    CANAL_PRINT("%sBspdFault: %u", sep, PedalPositions.BspdFault);
    CANAL_PRINT("%sMC_PedalPosition: %u", sep, PedalPositions.MC_PedalPosition);
    CANAL_PRINT("\n\r");
}

TeCanALRet Print_Message(uint32_t *ID) {
	CanALPrinter* print;

	for (int i = 0; i < TOTAL_MESSAGES; i++) {
		if ((*ID) == CANAL_PRINTER_TABLE[i].ID) {
			print = CANAL_PRINTER_TABLE[i].printer;

			(*print)();

			return CANAL_OK;
		}
	}

	return CANAL_UNSUPPORTED_TX_MESSAGE;
}

TeCanALRet GetTxDataLength(TeMessageID *ID, uint32_t *dlc) {
	for (int i = 0; i < NUM_TX_MESSAGES; i++) {
			if ((*ID) == CANAL_TX_MESSAGE_TABLE[i].ID) {
				*dlc = CANAL_TX_MESSAGE_TABLE[i].dlc;

				return CANAL_OK;
			}
		}

    return CANAL_UNSUPPORTED_TX_MESSAGE;
}

// UnmarshalBinary acts as a generic binary unmarshaller
TeCanALRet UnmarshalBinary(uint32_t *ID, uint8_t* rawData) {
	BinaryUnmarshaller* unmarshal;
	TeCanALRet ret;
 
	if ((ret = getBinaryUnmarshaller(ID, &unmarshal)) != CANAL_OK)
		return ret;
 
	return (*unmarshal)(rawData);
}

// MarshalBinary acts as a generic binary marshaller
TeCanALRet MarshalBinary(TeMessageID *ID, uint8_t* txData) {
	BinaryMarshaller* marshal;
	TeCanALRet ret;
 
	if ((ret = getBinaryMarshaller(ID, &marshal)) != CANAL_OK) return ret;
 
	return (*marshal)(txData);
}

