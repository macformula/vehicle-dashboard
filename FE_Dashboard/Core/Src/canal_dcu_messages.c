/*
 * canal_messages.c
 * DCU
 *
 *  WARNING: DO NOT EDIT. THIS WAS AN AUTOGENERATED FILE.
 *
 *  Created on: 2023/10/3 
 *     Authors: Samuel Parent, Dharak Verma
 *
 *                    ..::^~~~!!~~~^^:..
 *                .:^!7??JJJJJJJJJJJJ??7!~:.
 *              :~7?JJJ???????????????JJJJ??!^.
 *           .^7?JJJ???JJJJJJ??????????????JJJ?~:
 *          ^7JJ???????777777???JJJJJJJ???????JJ?~.
 *        .!JJ???????????7!~^::::^~!!7??JJ???????J7:
 *       :7JJJ??????????JJJJ??7~:    ..:~7?J??????J?^
 *      .7J???????????????????JJ?!.       :7J??????J?^
 *     .~J??????????????????JJJJ?!.       .7J???????J7.
 *     :?J?????????????JJJJ??7!^.      .:~???????????J~
 *     ^???????????JJJ??7~^:..      .:~7?JJ??????????J!.
 *     ^????????JJ?7~^:.        .:~!?JJJ?????????????J!.
 *     ^????????!^.          .:~7?JJJ????????????????J!.
 *     .7J????!.            :7?JJ?????????????????????^
 *      ~JJ?J7.             ~JJJJ???????????????????J!.
 *      .!J???^.            .^!7?JJJJJJ????????????J7:
 *       .!?J??7^.              .:^~!7???JJJJJ????J7:
 *        .^?JJJJ?7~.                 ..:^~~!7????!.
 *          .!?JJJJ?:                         ..::
 *            :~??!:
 *              ..
 */
 

 /*********************************************************
 *                      INCLUDES
 *********************************************************/
#include <stdint.h>
#include "canal_messages.h"

/*********************************************************
 *                       MACROS
 *********************************************************/
#define CANAL_DATA_BITS (64U)

// CANAL_BIT_MASK will output a mask with (__length__) number of 1's
// e.g.: CANAL_BIT_MASK(5) = 0b0001'1111
#define CANAL_BIT_MASK(__length__) 	(UINT64_MAX >> (CANAL_DATA_BITS - __length__))
    
// CANAL_BIT_INDEX_BE will take a bit index and convert it to work with big endian data
#define CANAL_BIT_INDEX_BE(__idx__) 	((7 - ((__idx__) % 8)) + (((__idx__) / 8) * 8))

// CANAL_CLEAR_BITS will output the contents of (__data__) with bits from (__start__)
// to (__start__+__length__) set to 0
#define CANAL_CLEAR_BITS(__data__, __start__, __length__) 	(~((CANAL_BIT_MASK(__length__) << __start__)) & (__data__))

// CANAL_GET_BITS will output the bits from (__data__) at bit positions (__start__)
// to (__start__+__length__)
#define CANAL_GET_BITS(__data__, __start__, __length__) 	((__data__ >>  __start__) & CANAL_BIT_MASK(__length__))

// CANAL_SET_BITS will take the first (__length__) bits from (__input__) and set them
// to (__output__) from bit position (__start__) to (__start__ + __length__)
#define CANAL_SET_BITS(__input__, __output__, __start__, __length__) 	(CANAL_CLEAR_BITS(__output__, __start__, __length__) | ((uint64_t)(__input__) & CANAL_BIT_MASK(__length__)) << __start__)

// CANAL_TWOS_COMPLEMENT will take the twos complement of (__data__)
#define CANAL_TWOS_COMPLEMENT(__data__, __length__) (((~(__data__))+1) & CANAL_BIT_MASK(__length__))

// CANAL_IS_NEGATIVE checks the msb to see if (__data__) is negative
#define CANAL_IS_NEGATIVE(__data__, __length__) (((__data__) & ((uint64_t)1 << (__length__-1))) != 0)

// CANAL_TO_SIGNED converts (__data__) to a signed value
#define CANAL_TO_SIGNED(__data__, __length__)   ((signed)(CANAL_IS_NEGATIVE(__data__, __length__) ? -(CANAL_TWOS_COMPLEMENT(__data__, __length__)) : __data__))

    
/*********************************************************
*                 GLOBAL STRUCT DEFINITIONS
*********************************************************/

//using the defined message struct types, inits the global structs of these typedefs to store messages in
volatile TsVehicleInfo          VehicleInfo;
volatile TsDashboardAnswer      DashboardAnswer;
volatile TsDashboardQuestion    DashboardQuestion;

//CAN dash message struct GLOBAL INSTANCE: 1 struct, populated differently dep on current CAN message being provided
volatile S_DashMessage			DashMessage;
	//Global instance therefore acts as the global dash message being provided

/*********************************************************
*           GLOBAL CAN MESSAGE QUEUE DEFINTIONS
*********************************************************/

/* Definitions for canVehicleInfoQueue */

const osMessageQueueAttr_t canVehicleInfoQueue_attributes = {
    .name = "canVehicleInfoQueue"};

canVehicleInfoQueue = osMessageQueueNew(16, sizeof(S_DashMessage), &canVehicleInfoQueue_attributes); //creating a new CAN queue for this program execution
//max 16 messages in queue
//1 message size is equal to the size of the standard DASHMESSAGE being provided to GUI
//link to config queue attribute struct via the struct's ptr that corresponds to this q
//not restricted by type

/*********************************************************
 *                    HELPER FUNCTIONS
 *********************************************************/
static uint64_t getDataWordFromByteArray(uint8_t* rawData) {
	uint64_t ret = 0;

	for (int8_t i = 7; i >= 0; i--) {
		ret <<= 8;
		ret += rawData[i];
	}

	return ret;
}

static void setDataWordIntoByteArray(uint64_t dataWord, uint8_t *dataOutput) {
	for (int8_t i = 0; i < 8; i++) {
		dataOutput[i] = (uint8_t) (dataWord & CANAL_BIT_MASK(8));
		dataWord >>= 8;
	}
}

static uint64_t shift_endianness(uint64_t val, uint8_t num_bits) {
	unsigned long long result = 0;
	unsigned long long temp_value = val;
	unsigned int num_bytes = (num_bits + 7) / 8;
	unsigned int num_shifts = (num_bytes - 1) * 8;
	
	for (unsigned int i = 0; i < num_bytes; ++i) {
		result |= ((temp_value >> (num_shifts - (i * 8))) & 0xFFULL) << (i * 8);
	}

	return result;
}

/*********************************************************
 *                    CAN FUNCTIONS
 *********************************************************/
TeCanALRet Unmarshal_VehicleInfo(uint8_t *RxData) {
	uint64_t data;
	TsVehicleInfo temp; //defines a temporary struct of type TsVehicleInfo
	//given that this unmarshal function was called, the ID of the current CAN message is: 
	canMessageId = VEHICLEINFO_CANAL_ID;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.MaximumPowerAvailablePercentage = CANAL_GET_BITS(data,
            VEHICLEINFO_MAXIMUMPOWERAVAILABLEPERCENTAGE_START,
            VEHICLEINFO_MAXIMUMPOWERAVAILABLEPERCENTAGE_LENGTH);
            
        temp.SocPercentage = CANAL_GET_BITS(data, 
            VEHICLEINFO_SOCPERCENTAGE_START,
            VEHICLEINFO_SOCPERCENTAGE_LENGTH);
            
        temp.VcuErrors = CANAL_GET_BITS(data,
            VEHICLEINFO_VCUERRORS_START,
            VEHICLEINFO_VCUERRORS_LENGTH);
            
        temp.VehicleSpeed = CANAL_GET_BITS(data,
            VEHICLEINFO_VEHICLESPEED_START,
            VEHICLEINFO_VEHICLESPEED_LENGTH);
            
        temp.VehicleStatus = CANAL_GET_BITS(data,
            VEHICLEINFO_VEHICLESTATUS_START,
            VEHICLEINFO_VEHICLESTATUS_LENGTH);
            
	//  Apply linear conversion
	temp.MaximumPowerAvailablePercentage = (temp.MaximumPowerAvailablePercentage
			* VEHICLEINFO_MAXIMUMPOWERAVAILABLEPERCENTAGE_FACTOR)
			+ VEHICLEINFO_MAXIMUMPOWERAVAILABLEPERCENTAGE_OFFSET; 
            
	temp.SocPercentage = (temp.SocPercentage
			* VEHICLEINFO_SOCPERCENTAGE_FACTOR)
			+ VEHICLEINFO_SOCPERCENTAGE_OFFSET; 
            
	temp.VcuErrors = (temp.VcuErrors
			* VEHICLEINFO_VCUERRORS_FACTOR)
			+ VEHICLEINFO_VCUERRORS_OFFSET; 
            
	temp.VehicleSpeed = (temp.VehicleSpeed
			* VEHICLEINFO_VEHICLESPEED_FACTOR)
			+ VEHICLEINFO_VEHICLESPEED_OFFSET; 
            
	temp.VehicleStatus = (temp.VehicleStatus
			* VEHICLEINFO_VEHICLESTATUS_FACTOR)
			+ VEHICLEINFO_VEHICLESTATUS_OFFSET; 
            
	//  Writing to global struct instance
	VehicleInfo = temp;
	
	//Current Approach: Do this within the unmarshaller of the corresponding function
		//OR use a table using the CANID enum. Given the value of the ENUM, 
	//DashMessage struct: Writing both VehicleInfo and canId to the higher-level dash struct for transmission to GUI
	DashMessage.VehicleInfo = temp;
	DashMessage.canMessageId = canMessageId;

	// Lastly, place the received message unmarshalled into VehicleInfo struct into the canQ
	if (osMessageQueueGetSpace(canVehicleInfoQueue) > 0)
  	{
		osMessageQueuePut(canVehicleInfoQueue, DashMessage, 0, 0);
  	} 	

	return CANAL_OK;
}


TeCanALRet Unmarshal_DashboardQuestion(uint8_t *RxData) {
	uint64_t data;
	TsDashboardQuestion temp;
	canMessageId = DASHBOARDQUESTION_CANAL_ID;

	data = getDataWordFromByteArray(RxData);
    
	//  Read raw bits
        temp.DcuQuestion = CANAL_GET_BITS(data,
            DASHBOARDQUESTION_DCUQUESTION_START,
            DASHBOARDQUESTION_DCUQUESTION_LENGTH);
            
	//  Apply linear conversion
	temp.DcuQuestion = (temp.DcuQuestion
			* DASHBOARDQUESTION_DCUQUESTION_FACTOR)
			+ DASHBOARDQUESTION_DCUQUESTION_OFFSET; 
            
	//  Writing to global struct instance
	DashboardQuestion = temp;

	return CANAL_OK;
}

TeCanALRet Marshal_DashboardAnswer(uint8_t *TxData) {
	uint64_t dataWord = 0;
	TsDashboardAnswer temp;
	TeCanALRet ret;

	temp = DashboardAnswer;
    
    // Reverse linear conversion
	temp.DcuAnswer = (temp.DcuAnswer
			- DASHBOARDANSWER_DCUANSWER_OFFSET)
			/ DASHBOARDANSWER_DCUANSWER_FACTOR;
            
    // CANAL_SET_BITS only writes to correct bits, dataWord is not being overwritten
	dataWord = CANAL_SET_BITS(temp.DcuAnswer, dataWord,
            //little_endian
            DASHBOARDANSWER_DCUANSWER_START,
			DASHBOARDANSWER_DCUANSWER_LENGTH);
            
	setDataWordIntoByteArray(dataWord, TxData);

	return CANAL_OK;
}

/*********************************************************
 *               FUNCTION POINTER TABLE
 *********************************************************/

//For accessing the binary unmarshaller for received messages
static const struct {
	TeMessageID ID;
	BinaryUnmarshaller *Unmarshal; //function ptr to unmarshal function
} CANAL_RX_MESSAGE_TABLE[NUM_RX_MESSAGES] = {
	{ VEHICLEINFO_CANAL_ID,          &Unmarshal_VehicleInfo },
	{ DASHBOARDQUESTION_CANAL_ID,    &Unmarshal_DashboardQuestion },
};

//For accessing the transmitted messages
static const struct {
	TeMessageID ID;
	BinaryMarshaller *Marshal;
    uint32_t dlc;
} CANAL_TX_MESSAGE_TABLE[NUM_TX_MESSAGES] = {
	{ DASHBOARDANSWER_CANAL_ID,      &Marshal_DashboardAnswer,      DASHBOARDANSWER_DATA_LENGTH },
};

//For printing
static const struct {
	TeMessageID ID;
	CanALPrinter* printer;
} CANAL_PRINTER_TABLE[TOTAL_MESSAGES] = {
	{ VEHICLEINFO_CANAL_ID,          &Print_VehicleInfo },
	{ DASHBOARDANSWER_CANAL_ID,      &Print_DashboardAnswer },
	{ DASHBOARDQUESTION_CANAL_ID,    &Print_DashboardQuestion },
};

/*********************************************************
 *           FUNCTION POINTER TABLE GETTERS
 *********************************************************/
static TeCanALRet getBinaryUnmarshaller(uint32_t *ID, BinaryUnmarshaller **pUnmarshal) {
	for (int i = 0; i < NUM_RX_MESSAGES; i++) {
		if ((*ID) == CANAL_RX_MESSAGE_TABLE[i].ID) {
			*pUnmarshal = CANAL_RX_MESSAGE_TABLE[i].Unmarshal;
			//manually checking each message ID (CANAL_RX_MESSAGE_TABLE[i].ID) 
			//in table against the passed in ID of the current CAN message

			return CANAL_OK;
		}
	}

	return CANAL_UNSUPPORTED_RX_MESSAGE;
}

static TeCanALRet getBinaryMarshaller(TeMessageID *ID, BinaryMarshaller **pMarshal) {
	for (int i = 0; i < NUM_TX_MESSAGES; i++) {
		if ((*ID) == CANAL_TX_MESSAGE_TABLE[i].ID) {
			*pMarshal = CANAL_TX_MESSAGE_TABLE[i].Marshal;

			return CANAL_OK;
		}
	}

	return CANAL_UNSUPPORTED_TX_MESSAGE;
}

/*********************************************************
 *             PUBLIC FUNCTION DEFINITIONS
 *********************************************************/
void Print_VehicleInfo() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: VehicleInfo");
    CANAL_PRINT("%sMaximumPowerAvailablePercentage: %u", sep, VehicleInfo.MaximumPowerAvailablePercentage);
    CANAL_PRINT("%sSocPercentage: %u", sep, VehicleInfo.SocPercentage);
    CANAL_PRINT("%sVcuErrors: %u", sep, VehicleInfo.VcuErrors);
    CANAL_PRINT("%sVehicleSpeed: %u", sep, VehicleInfo.VehicleSpeed);
    CANAL_PRINT("%sVehicleStatus: %u", sep, VehicleInfo.VehicleStatus);
    CANAL_PRINT("\n\r");
}
void Print_DashboardAnswer() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: DashboardAnswer");
    CANAL_PRINT("%sDcuAnswer: %u", sep, DashboardAnswer.DcuAnswer);
    CANAL_PRINT("\n\r");
}
void Print_DashboardQuestion() {
	char* sep ="\n\r\t";

	CANAL_PRINT("MESSAGE: DashboardQuestion");
    CANAL_PRINT("%sDcuQuestion: %u", sep, DashboardQuestion.DcuQuestion);
    CANAL_PRINT("\n\r");
}

TeCanALRet Print_Message(uint32_t *ID) {
	CanALPrinter* print;

	for (int i = 0; i < TOTAL_MESSAGES; i++) {
		if ((*ID) == CANAL_PRINTER_TABLE[i].ID) {
			print = CANAL_PRINTER_TABLE[i].printer;

			(*print)();

			return CANAL_OK;
		}
	}

	return CANAL_UNSUPPORTED_TX_MESSAGE;
}

TeCanALRet GetTxDataLength(TeMessageID *ID, uint32_t *dlc) {
	for (int i = 0; i < NUM_TX_MESSAGES; i++) {
			if ((*ID) == CANAL_TX_MESSAGE_TABLE[i].ID) {
				*dlc = CANAL_TX_MESSAGE_TABLE[i].dlc;

				return CANAL_OK;
			}
		}

    return CANAL_UNSUPPORTED_TX_MESSAGE;
}

// UnmarshalBinary acts as a generic binary unmarshaller
TeCanALRet UnmarshalBinary(uint32_t *ID, uint8_t* rawData) {
	BinaryUnmarshaller* unmarshal;
	TeCanALRet ret;
 
	if ((ret = getBinaryUnmarshaller(ID, &unmarshal)) != CANAL_OK)
		return ret;
 
	return (*unmarshal)(rawData);
}

// MarshalBinary acts as a generic binary marshaller
TeCanALRet MarshalBinary(TeMessageID *ID, uint8_t* txData) {
	BinaryMarshaller* marshal;
	TeCanALRet ret;
 
	if ((ret = getBinaryMarshaller(ID, &marshal)) != CANAL_OK) return ret;
 
	return (*marshal)(txData);
}

